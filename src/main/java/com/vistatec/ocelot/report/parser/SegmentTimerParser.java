package com.vistatec.ocelot.report.parser;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.log4j.Logger;

import com.vistatec.ocelot.report.model.FileTiming;
import com.vistatec.ocelot.report.model.SegmentTiming;

/**
 * Parser for session timings files generated by the SegmentTimer plugin.
 */
public class SegmentTimerParser {

	/** Index of the start time info. */
	private static final int START_TIME_IDX = 0;

	/** Index of the end time info. */
	private static final int END_TIME_IDX = 4;

	/** Index of the file info. */
	private static final int FILE_IDX = 3;

	/** Index of the segment number info. */
	private static final int SEGMENT_IDX = 2;

	/** String included into the row where the name of the file is stored. */
	private static final String FILE_STRING = "Opened file";

	/** String included in the Segment string. */
	private static final String SEGMENT_STRING = "Segment#";

	/** Separator used in the file. */
	private static final String SEPARATOR = "\t";
	
	/** Logger for this class. */
	private final Logger logger = Logger.getLogger(SegmentTimerParser.class);

	/** temporary map for storing retrieved timings information. */
	private Map<String, Map<String, Double>> file2Time;

	/** name of the file found in the last file row encountered. */
	private String currentFile;

	/**
	 * Parses the file passed as parameter.
	 * 
	 * @param file
	 *            the session timings file
	 * @return the list of retrieved timing information.
	 * @throws IOException
	 *             the IO exception
	 */
	public List<FileTiming> parse(File file) throws IOException {

		logger.debug("Parsing the time session file " + file.getName() + "...");
		file2Time = new HashMap<String, Map<String, Double>>();
		parseFile(file);
		logger.debug("File " + file.getName() + " parsed.");
		return getTimings();
	}

	/**
	 * Converts the timings retrieved in the map to a list of file timnings.
	 * 
	 * @return the list of timings
	 */
	private List<FileTiming> getTimings() {
		logger.debug("Generating timings info...");
		List<FileTiming> timings = new ArrayList<FileTiming>();
		double total = 0;
		FileTiming fileTiming = null;
		for (Entry<String, Map<String, Double>> fileEntry : file2Time
		        .entrySet()) {
			List<SegmentTiming> segments = new ArrayList<SegmentTiming>();
			SegmentTiming segTiming = null;
			for (Entry<String, Double> entry : fileEntry.getValue().entrySet()) {
				segTiming = new SegmentTiming(entry.getKey(), entry.getValue());
				total += entry.getValue();
				segments.add(segTiming);
			}
			fileTiming = new FileTiming(fileEntry.getKey(), total, segments);
			timings.add(fileTiming);
		}

		return timings;
	}

	/**
	 * Parses the file and puts all retrieved timings into the map.
	 * 
	 * @param file
	 *            the file to be parsed
	 * @throws IOException
	 *             the IO exception
	 */
	private void parseFile(File file) throws IOException {
		BufferedReader reader = null;
		try {
			FileInputStream inStream = new FileInputStream(file);
			reader = new BufferedReader(new InputStreamReader(inStream));
			String line = null;
			// parse the file line by line
			while ((line = reader.readLine()) != null) {
				// parse the line.
				parseLine(line);
			}
		} finally {
			if (reader != null) {
				reader.close();
			}
		}
	}

	/**
	 * Parses a single line from the file.
	 * 
	 * @param line
	 *            the line
	 */
	private void parseLine(String line) {

		if (line.contains(FILE_STRING)) {
			// if the line contains info about the file, save the file name
			String[] splittedLine = line.split(SEPARATOR);
			currentFile = splittedLine[FILE_IDX].replaceAll("'", "");
			logger.debug("Starting parsing segment timings for file " + currentFile);
		} else if (line.contains(SEGMENT_STRING)) {
			// if the line contains info about the segments, then store segments
			// info in the map
			String[] splittedLine = line.split(SEPARATOR);
			String segNumber = splittedLine[SEGMENT_IDX]
			        .substring(SEGMENT_STRING.length());
			double startTime = Double.parseDouble(splittedLine[START_TIME_IDX]);
			// this check is needed because there could be lines with a start
			// date, but with no end date.
			// Those lines are discarded.
			if (END_TIME_IDX < splittedLine.length) {

				double endTime = Double.parseDouble(splittedLine[END_TIME_IDX]);
				addSegmentTiming(segNumber, endTime - startTime);
			}
		}
	}

	/**
	 * Adds a segment timing to the current file.
	 * 
	 * @param segNum
	 *            the segment number
	 * @param timing
	 *            the segment timing
	 */
	private void addSegmentTiming(String segNum, double timing) {
		if (!file2Time.containsKey(currentFile)) {
			file2Time.put(currentFile, new HashMap<String, Double>());
		}
		Map<String, Double> segments2Time = file2Time.get(currentFile);
		if (segments2Time.containsKey(segNum)) {
			segments2Time.put(segNum, segments2Time.get(segNum) + timing);
		} else {
			segments2Time.put(segNum, timing);
		}
	}

}

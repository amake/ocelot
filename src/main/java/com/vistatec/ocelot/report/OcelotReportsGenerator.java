package com.vistatec.ocelot.report;

import java.awt.Window;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;

import org.apache.log4j.Logger;

import com.vistatec.ocelot.report.model.FileTiming;
import com.vistatec.ocelot.report.parser.SegmentTimerParser;
import com.vistatec.ocelot.report.writer.SegmentTimingWriter;

/**
 * This class generates reports for Ocelot.
 */
public class OcelotReportsGenerator {

	/**
	 * Prefix string used in all session timings files name generated by the
	 * Segment Timer plugin.
	 */
	private final static String SESSION_TIMINGS_FILE_NAME = "SessionTimings";

	/** Segment Timer files extension. */
	private final static String SESSION_TIMINGS_FILE_EXT = ".csv";

	private final Logger logger = Logger
			.getLogger(OcelotReportsGenerator.class);

	/** Current opened Ocelot window. */
	private Window ownerWindow;

	/**
	 * Constructor.
	 * 
	 * @param ownerWindow
	 *            the Ocelot window.
	 */
	public OcelotReportsGenerator(final Window ownerWindow) {

		this.ownerWindow = ownerWindow;
	}

	/**
	 * Generates the time capture reports by parsing the session files generated
	 * by the SegmentTimer plugin.
	 */
	public void generateTimeCaptureReports() {

		logger.info("Request to generate time-capture reports.");
		File folder = chooseFolder();
		if (folder != null) {
			File[] files = folder.listFiles();
			SegmentTimerParser parser = new SegmentTimerParser();
			try {
				List<FileTiming> timings = new ArrayList<FileTiming>();
				for (File file : files) {
					// checks if the file is a session timings file
					if (file.getName().startsWith(SESSION_TIMINGS_FILE_NAME)
							&& file.getName()
									.endsWith(SESSION_TIMINGS_FILE_EXT)) {
						// parse the file
						List<FileTiming> partialTimings = parser.parse(file);
						// merge the timings generated at this step with those
						// previously generated
						merge(timings, partialTimings);
					}
				}
				// Write the report
				SegmentTimingWriter writer = new SegmentTimingWriter();
				for (FileTiming timing : timings) {
					writer.write(folder.getAbsolutePath(), timing);
				}
				// prompt a success message to the user.
				JOptionPane
						.showMessageDialog(ownerWindow,
								"Time-capture Reports successfully generated.",
								"Time-capture Reports",
								JOptionPane.INFORMATION_MESSAGE);
			} catch (IOException e) {

				logger.error(
						"Error while generating the Time-capture reports.", e);
				JOptionPane
						.showMessageDialog(
								ownerWindow,
								"An error occurred while generating the reports.",
								"Time-capture Reports Error",
								JOptionPane.ERROR_MESSAGE);
			}
		}
	}

	/**
	 * Let the user choose the folder to be used during Report generation.
	 * 
	 * @return the folder
	 */
	private File chooseFolder() {

		File folder = null;
		JFileChooser fileChooser = new JFileChooser();
		fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
		fileChooser.setAcceptAllFileFilterUsed(false);
		int option = fileChooser.showOpenDialog(ownerWindow);
		if (option == JFileChooser.APPROVE_OPTION) {
			folder = fileChooser.getSelectedFile();
			logger.debug(folder.getAbsoluteFile() + " folder selected.");
		}
		return folder;
	}

	/**
	 * Merges two lists of timings.
	 * 
	 * @param finalTimings
	 *            the final timings list where all the timings are merged.
	 * @param partialTimings
	 *            the partial timings to be merged to the final ones.
	 */
	private void merge(List<FileTiming> finalTimings,
			List<FileTiming> partialTimings) {

		for (FileTiming partialTiming : partialTimings) {
			if (finalTimings.contains(partialTiming)) {
				finalTimings.get(finalTimings.indexOf(partialTiming)).merge(
						partialTiming);
			} else {
				finalTimings.add(partialTiming);
			}
		}
	}

}
